<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Fly High</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Hexo theme - Icarus">
<meta property="og:type" content="website">
<meta property="og:title" content="Fly High">
<meta property="og:url" content="http://shijianguang.github.io/index.html">
<meta property="og:site_name" content="Fly High">
<meta property="og:description" content="Hexo theme - Icarus">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fly High">
<meta name="twitter:description" content="Hexo theme - Icarus">
  
  
    <link rel="icon" href="favicon.png">
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo" style="background-image: url(/css/images/logo.png)"></i><span class="site-title">Fly High</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      
        <nav id="sub-nav">
          <div class="profile" id="profile-nav">
            <a id="profile-anchor" href="javascript:;"><img class="avatar" src="/css/images/avatar.png"><i class="fa fa-caret-down"></i></a>
          </div>
        </nav>
      
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="http://shijianguang.github.io"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
        
          <td><a class="main-nav-link" href="/.">Home</a></td>
        
          <td><a class="main-nav-link" href="/archives">Archives</a></td>
        
          <td><a class="main-nav-link" href="/categories">Categories</a></td>
        
          <td><a class="main-nav-link" href="/tags">Tags</a></td>
        
          <td><a class="main-nav-link" href="/about">About</a></td>
        
        <td>
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://shijianguang.github.io"></form>
        </td>
      </tr>
    </table>
  </div>
</header>

    <div class="outer">
      
        <aside id="profile">
  <div class="inner profile-inner">
    <div class="base-info profile-block">
      <img id="avatar" src="/css/images/avatar.png">
      <h2 id="name">Jianguang Shi</h2>
      <h3 id="title">Backend Developer</h3>
      <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
      <a id="follow" href="null">FOLLOW</a>
    </div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        4
        <span>posts</span>
      </div>
      <div class="article-info-block">
        4
        <span>tags</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
          
          <td><a href="http://github.com/ppoffice/hexo-theme-icarus" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
          
          <td><a href="/#" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
          
          <td><a href="/#" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
          
          <td><a href="/#" target="_blank" title="dribbble"><i class="fa fa-dribbble"></i></a></td>
          
          <td><a href="/atom.xml" target="_blank" title="rss"><i class="fa fa-rss"></i></a></td>
          
        </tr>
      </table>
    </div>
    
    
  </div>
</aside>

      
      <section id="main">
      <article id="post-C-右值引用和转移语义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/28/C-右值引用和转移语义/">C++ 右值引用和转移语义</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2016/08/28/C-右值引用和转移语义/">
      <time datetime="2016-08-28T04:13:02.000Z" itemprop="datePublished">2016-08-28</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>右值引用(Rvalue Reference)是C++11标准中引入的特性，基于右值引用，C++11实现了转移语义(Move Sementics)和精确传递(Perfect Forwarding)。这几个特性也是C++11中的重要的新特性，用以提升C++语言的核心性能和计算速度。主要体现在一下方面：</p>
<ol>
<li>以右值引用为基础的转移语义，消除了对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>精确传递能够使开发者更简洁明确的定义泛型函数。</li>
</ol>
<h2 id="传统C++中的对象构造、拷贝构造和赋值操作">传统C++中的对象构造、拷贝构造和赋值操作</h2><p>在探讨右值引用的问题之前，我们先来看一下C++11之前的代码中，对象的传递是如何进行的。在C++11之前，对象的传递主要跟构造函数，拷贝构造函数和赋值构造函数。具体参见实例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">class</span> MyString &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* _data;</span><br><span class="line">    <span class="keyword">size_t</span> _len;</span><br><span class="line">    <span class="keyword">void</span> _init_data(<span class="keyword">const</span> <span class="keyword">char</span> *s) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len);</span><br><span class="line">        _data[_len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyString() &#123;</span><br><span class="line">        _data = <span class="literal">NULL</span>;</span><br><span class="line">        _len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString(<span class="keyword">const</span> <span class="keyword">char</span>* p) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _len = <span class="number">0</span>;</span><br><span class="line">            _data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _len = <span class="built_in">strlen</span>(p);</span><br><span class="line">            _init_data(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Constructor is called! source: "</span> &lt;&lt; (_data == <span class="literal">NULL</span> ? <span class="string">"NULL"</span> : _data) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str._len == <span class="number">0</span> &amp;&amp; str._data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            _len = <span class="number">0</span>;</span><br><span class="line">            _data = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _len = str._len;</span><br><span class="line">            _init_data(str._data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Constructor is called! source: "</span> &lt;&lt; (_data == <span class="literal">NULL</span> ? <span class="string">"NULL"</span> : _data)</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str._len == <span class="number">0</span> &amp;&amp; str._data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                _len = <span class="number">0</span>;</span><br><span class="line">                _data = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                _len = str._len;</span><br><span class="line">                _init_data(str._data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Copy Assignment is called! source: "</span> &lt;&lt; (_data == <span class="literal">NULL</span> ? <span class="string">"NULL"</span> : _data)</span><br><span class="line">                &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span> * <span class="title">get_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~MyString() &#123;</span><br><span class="line">        <span class="keyword">if</span> (_data != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Deconstructor is called"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyString <span class="title">get_new_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World 5"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"##########Begin Rvalue Test##########"</span> &lt;&lt; endl;</span><br><span class="line">    MyString a;</span><br><span class="line">    MyString b = <span class="string">"Hello World 1"</span>;</span><br><span class="line">    a = MyString(<span class="string">"Hello world 2"</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MyString&gt; vec;</span><br><span class="line">    vec.reserve(<span class="number">128</span>);</span><br><span class="line">    vec.push_back(<span class="string">"Hello World 3"</span>);</span><br><span class="line">    MyString c = get_new_string();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c.get_data() &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"##########End Rvalue Test##########"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例程序的输出是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">##########Begin Rvalue Test##########</span></span><br><span class="line">Constructor is called! source: Hello World <span class="number">1</span></span><br><span class="line">Constructor is called! source: Hello world <span class="number">2</span></span><br><span class="line">Copy Assignment is called! source: Hello world <span class="number">2</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Constructor is called! source: Hello World <span class="number">3</span></span><br><span class="line">Copy Constructor is called! source: Hello World <span class="number">3</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Constructor is called! source: Hello World <span class="number">5</span></span><br><span class="line">Hello World <span class="number">5</span></span><br><span class="line"><span class="preprocessor">##########End Rvalue Test##########</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br></pre></td></tr></table></figure>
<p>从实例中可以得到如下的结论：</p>
<ol>
<li>虽然关于b的表达式是 <code>b = &quot;Hello World 1&quot;</code>，但因为是出现在变量定义的阶段，所以是一个初始化操作，调用了参数是const char * 的构造函数。</li>
<li>使用一个临时对象MyString(“Hello World 2”)赋值给变量a，这个过程中，临时变量需要调用构造函数，然后通过拷贝构造函数完成对a的赋值，最后通过析构函数释放掉这个临时对象。</li>
<li>向vector中放入一个”Hello World 3“对象，首先通过const char *构造函数构造一个临时对象，然后在push_back函数内部通过拷贝构造函数，将这个临时对象拷贝到vector内部的存储空间中，最后通过析构函数释放临时对象。</li>
<li>get_new_string()函数返回一个MyString的对象，这里没有产生临时对象，执行拷贝构造的原因是gcc编译器使用了返回值优化，避免了对于的调用。</li>
</ol>
<h2 id="左值和右值">左值和右值</h2><p>C++( 包括 C) 中所有的表达式和变量要么是左值，要么是右值。通俗的左值的定义就是非临时对象，那些可以在多条语句中使用的对象。所有的变量都满足这个定义，在多条代码中都可以使用，都是左值。右值是指临时的对象，它们只在当前的语句中有效。比如上述实例代码中，变量a, b, vec, c都是左值，而”Hello World1”, MyString(“Hellow World 2”) 和 “Hello World 5”都是右值。</p>
<p>在C++中，左值的引用使用符号 <code>&amp;</code> 表示，右值的引用通过 <code>&amp;&amp;</code>表示，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; b = a;  <span class="comment">//左值引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; c = <span class="number">1</span>; <span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>
<p>示例程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_function</span><span class="params">(<span class="keyword">int</span> &amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Left Value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_function</span><span class="params">(<span class="keyword">int</span> &amp;&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">right_value_2_left_value</span><span class="params">(<span class="keyword">int</span> &amp;&amp; i)</span> </span>&#123;</span><br><span class="line">    process_function(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    process_function(i);</span><br><span class="line">    process_function(<span class="number">2</span>);</span><br><span class="line">    right_value_2_left_value(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Left Value: <span class="number">1</span></span><br><span class="line">Right Value: <span class="number">2</span></span><br><span class="line">Left Value: <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>i</strong> 被当做左值进行传递，<strong>2</strong> 被当做右值进行传递，<strong>3</strong> 虽然是一个右值，但进入<strong>right_value_2_left_value</strong>这个函数中后，被转换成了左值。</p>
<h2 id="转移语义">转移语义</h2><p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。<br>转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。<br>通过转移语义，临时对象中的资源能够转移其它的对象里。<br>在现有的 C++ 机制中，如果我们要实现转移语义，需要定义转移构造函数，还可以定义转移赋值操作符。对于右值的拷贝和赋值会调用转移构造函数和转移赋值操作符。如果转移构造函数和转移拷贝操作符没有定义，那么就遵循现有的机制，拷贝构造函数和赋值操作符会被调用。<br>普通的函数和操作符也可以利用右值引用操作符实现转移语义。</p>
<p>比如我们在<strong>MyString</strong>中加入转移构造函数和转移复制函数，具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转移构造函数</span></span><br><span class="line">MyString(MyString&amp;&amp; str) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Constructor is called! source: "</span> &lt;&lt; str._data</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    _len = str._len;</span><br><span class="line">    _data = str._data;</span><br><span class="line">    str._len = <span class="number">0</span>;</span><br><span class="line">    str._data = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转移复制函数</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Move Assignment is called! source: "</span> &lt;&lt; str._data</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加完成后，重新运行测试程序，可以得到新的输出如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">##########Begin Rvalue Test##########</span></span><br><span class="line">Constructor is called! source: Hello World <span class="number">1</span></span><br><span class="line">Constructor is called! source: Hello world <span class="number">2</span></span><br><span class="line">Move Assignment is called! source: Hello world <span class="number">2</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Constructor is called! source: Hello World <span class="number">3</span></span><br><span class="line">Move Constructor is called! source: Hello World <span class="number">3</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Constructor is called! source: Hello World <span class="number">5</span></span><br><span class="line">Hello World <span class="number">5</span></span><br><span class="line"><span class="preprocessor">##########End Rvalue Test##########</span></span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br><span class="line">Deconstructor is called</span><br></pre></td></tr></table></figure>
<p>从结果可以看到，程序中有两个地方使用到了临时变量，第一处是赋值语句 <strong>a = MyString(“Hello world 2”);</strong>，在实现了转移复制函数后，这次赋值操作已经改为调用转移复制函数。第二处是函数传递参数<strong>vec.push_back(“Hello World 3”);</strong>，这里的操作已经改为调用转移构造函数。</p>
<p>这样的结果基本说明了转移语义的作用，在没有转移语义的时候，程序在<strong>a = MyString(“Hello world 2”);</strong> 和 <strong>vec.push_back(“Hello World 3”);</strong>这两处对两个临时变量实行了两次无用的复制操作，并且内存中每个临时变量有两个副本，一个是临时变量本身，另一个被拷贝到对应的左值中，同时在析构的时候，也要执行两次无用的内存释放操作来释放临时变量的内存。而定义了转移语义之后，这三个方面不必要性能消耗都已经被避免了。首先，转移操作通过内部资源的交换实现对左值的更新，避免了内存拷贝，同时也避免了临时变量中保存多余的内容，并且在析构过程中，由于转移操作将空指针转移给临时变量，所以不需要额外的内存释放操作。所以转移语义即节省了时间，有节省了空间</p>
<p>实现转移构造函数和转移赋值函数是要注意一下方面：</p>
<ol>
<li>参数必须是右值引用 &amp;&amp;</li>
<li>参数不能是常量，因为转移操作中需要修改参数</li>
<li>参数中资源需要妥善处理，避免参数被析构后，导致转移到的新对象不可用</li>
</ol>
<p>有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。</p>
<h2 id="std::move">std::move</h2><p>由上文可以看出，在C++程序中，虽然转移操作可以节省空间和时间，但是只有右值才能触发转移操作。而C++中所有的命名对象都是左值，那如果当我们明确知道一个左值已经不会再被使用，希望内部资源可以交换给别的左值时如何使用转移语义呢？这是时候需要使用标准库中的std::move()操作，这个操作将一个左值变成一个右值，进而使用转移操作。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_function</span><span class="params">(<span class="keyword">int</span> &amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Left Value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_function</span><span class="params">(<span class="keyword">int</span> &amp;&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Right Value: "</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    process_function(i);</span><br><span class="line">    process_function(<span class="built_in">std</span>::move(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line">Left Value: <span class="number">2</span></span><br><span class="line">Right Value: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h2 id="精确传递">精确传递</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://shijianguang.github.io/2016/08/28/C-右值引用和转移语义/" data-id="cisg8uycq000hdqs6xoummowf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li></ul>

    </footer>
  </div>
  
</article>



    
      <article id="post-C-wchar-t-表示中文字符" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/27/C-wchar-t-表示中文字符/">C++ wchar_t 表示中文字符</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2016/08/27/C-wchar-t-表示中文字符/">
      <time datetime="2016-08-27T12:32:36.000Z" itemprop="datePublished">2016-08-27</time>
    </a>
  </div>


          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Work/">Work</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>最近在工作中使用了一个开源的，基于C语言的<a href="https://linux.thai.net/~thep/datrie/datrie.html" target="_blank" rel="external">Double Array Trie数据结构</a>来构造keywords字典。这个开源版本的实现中，将uint32重定义为内部的AlphaChar类型，用来表示一个字符。而这样的表示方法，让自己在coding过程中需要进一步了解C/C++中如何表示和存储一个中文字符。</p>
<h2 id="编码相关知识">编码相关知识</h2><p>最早的字符编码是ASCII编码，使用7个bit表示一个字符，一共能表示128个字符。这对于英文内容来说已经足够了，但无法结果多国语言的问题，比如无法表示中文。而为了统一字符编码的问题，Unicode编码逐渐成为了一种现行的标准，它能够编码100多万中字符，每一个字符都有唯一的一个Unicode值与之对应。<br>Unicode虽然为多国语言的字符都定义了统一的编码，但并没有定义如何在计算机中表示这种编码。这里会存在诸多问题，比如Unicode使用多个自己进行编码，那么计算机如何知道当前这个字节是要表示一个ASCII字符，还是要表示一个Unicode字符中的一个字节。而这里就引出了大家平时常见UTF-8, UTF-16, UTF-32这些概念。它们和Unicode有什么关系呢？简单来说: <strong>UTF-8, UTF-16, UTF-32都是Unicode的一种具体实现。Unicode定义了每个字符对应的Unicode值，而这几种实现定了如何在计算机中表示这个值。这其中UTF-8是一种广泛使用的实现方法。他是一种变长编码，用1到4个字节来表示一个字符。具体内容可以参见<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="external">这篇博客</a></strong></p>
<h2 id="wchar_t_表示一个中文字符">wchar_t 表示一个中文字符</h2><p>在Java中，内存中的char实际上为2byte，默认采用Unicode的方式存储字符，所以在Java中，char型变量是可以表示一个中文字符的。而在C/C++中，char型变量本质上就是一个字节，无法表示一个中文字符，比如char * str = “分布式系统”，当使用strlen(str)来计算长度是，在我的Linux机器下长度是15而不是5。那如何表示一个中文字符呢？一种可行的办法是使用wchar_t来代替char.</p>
<p>wchar_t类型占用的字节数与操作系统有关，在Linux中，wchar_t占用四个字节。在工作中，将原始的char*字符串转换为wchat_t*字符串，然后迭代这个wchat_t*字符串，就可以顺利的使用前文提到的DAtrie来进行基于字典的关键词抽取。</p>
<p>C语言中提供了四个库函数用于char*和wchar_t*的互转，具体实例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//将一个char* 字符串src转换为wchar_t* 字符串 dst, len表示wchar_t* dst中的有多少个wchar_t的可用空间</span></span><br><span class="line"><span class="comment">//依赖一个全局的状态变量，线程不安全</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> mbstowcs( <span class="keyword">wchar_t</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="built_in">std</span>::<span class="keyword">size_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::setlocale(LC_ALL, <span class="string">"en_US.utf8"</span>);</span><br><span class="line">    <span class="built_in">std</span>::wcout.imbue(<span class="built_in">std</span>::locale(<span class="string">"en_US.utf8"</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mbstr = <span class="string">u8"z\u00df\u6c34\U0001f34c"</span>; <span class="comment">// or u8"zß水🍌"</span></span><br><span class="line">                        <span class="comment">// or "\x7a\xc3\x9f\xe6\xb0\xb4\xf0\x9f\x8d\x8c";</span></span><br><span class="line">    <span class="keyword">wchar_t</span> wstr[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">std</span>::mbstowcs(wstr, mbstr, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">"wide string: "</span> &lt;&lt; wstr &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个wchar_t* 字符串src转换成char* 字符串dst， len表示char* dst中有多少个char的可用空间</span></span><br><span class="line"><span class="comment">//依赖一个全局的状态变量，线程不安全</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> wcstombs( <span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">wchar_t</span>* src, <span class="built_in">std</span>::<span class="keyword">size_t</span> len);</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::setlocale(LC_ALL, <span class="string">"en_US.utf8"</span>);</span><br><span class="line">    <span class="comment">// UTF-8 narrow multibyte encoding</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* wstr = <span class="string">L"z\u00df\u6c34\U0001d10b"</span>; <span class="comment">// or L"zß水𝄋"</span></span><br><span class="line">    <span class="keyword">char</span> mbstr[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">std</span>::wcstombs(mbstr, wstr, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multibyte string: "</span> &lt;&lt; mbstr &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个char* 字符串src转换为wchar_t* 字符串 dst, len表示wchar_t* dst中的有多少个wchar_t的可用空间, ps表示转换状态变量</span></span><br><span class="line"><span class="comment">//不依赖全局的状态变量，线程安全</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> mbsrtowcs( <span class="keyword">wchar_t</span>* dst, <span class="keyword">const</span> <span class="keyword">char</span>** src, <span class="built_in">std</span>::<span class="keyword">size_t</span> len, <span class="built_in">std</span>::<span class="keyword">mbstate_t</span>* ps );</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cwchar&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_as_wide</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* mbstr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">mbstate_t</span> state = <span class="built_in">std</span>::<span class="keyword">mbstate_t</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> + <span class="built_in">std</span>::mbsrtowcs(<span class="literal">NULL</span>, &amp;mbstr, <span class="number">0</span>, &amp;state);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">wchar_t</span>&gt; wstr(len);</span><br><span class="line">    <span class="built_in">std</span>::mbsrtowcs(&amp;wstr[<span class="number">0</span>], &amp;mbstr, wstr.size(), &amp;state);</span><br><span class="line">    <span class="built_in">std</span>::wcout &lt;&lt; <span class="string">"Wide string: "</span> &lt;&lt; &amp;wstr[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">               &lt;&lt; <span class="string">"The length, including '\\0': "</span> &lt;&lt; wstr.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::setlocale(LC_ALL, <span class="string">"en_US.utf8"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* mbstr = <span class="string">u8"z\u00df\u6c34\U0001f34c"</span>; <span class="comment">// or u8"zß水🍌"</span></span><br><span class="line">    print_as_wide(mbstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将一个wchar_t* 字符串src转换为char* 字符串 dst, len表示wchar_t* dst中的有多少个wchar_t的可用空间, ps表示转换状态变量</span></span><br><span class="line"><span class="comment">//不依赖全局的状态变量，线程安全</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">size_t</span> wcsrtombs( <span class="keyword">char</span>* dst, <span class="keyword">const</span> <span class="keyword">wchar_t</span>** src, <span class="built_in">std</span>::<span class="keyword">size_t</span> len, <span class="built_in">std</span>::<span class="keyword">mbstate_t</span>* ps );</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cwchar&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_wide</span><span class="params">(<span class="keyword">const</span> wchar_t* wstr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">mbstate_t</span> state = <span class="built_in">std</span>::<span class="keyword">mbstate_t</span>();</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> + <span class="built_in">std</span>::wcsrtombs(<span class="literal">nullptr</span>, &amp;wstr, <span class="number">0</span>, &amp;state);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; mbstr(len);</span><br><span class="line">    <span class="built_in">std</span>::wcsrtombs(&amp;mbstr[<span class="number">0</span>], &amp;wstr, mbstr.size(), &amp;state);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"multibyte string: "</span> &lt;&lt; &amp;mbstr[<span class="number">0</span>] &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"Length, including '\\0': "</span> &lt;&lt; mbstr.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::setlocale(LC_ALL, <span class="string">"en_US.utf8"</span>);</span><br><span class="line">    <span class="comment">// UTF-8 narrow multibyte encoding</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">wchar_t</span>* wstr = <span class="string">L"z\u00df\u6c34\U0001d10b"</span>; <span class="comment">// or L"zß水𝄋"</span></span><br><span class="line">    print_wide(wstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中的 <strong>std::setlocale(LC_ALL, “en_US.utf8”);</strong> 调用指明了编码方式。wchar_t类型数组中，每一个元素可以表示一个字符，而当 wchar_t* 转化为 char* 时，一个wchar_t字符可能需要多个char字符来表示，这种转换就依赖于我们这顶的字符编码规则，这里按照utf8的编码方式，将一个wchar_t变成多个char。反之,将char*转化为wchar_t*时，需要知道char*的编码方式，这里就是utf8的编码方式，那么转换函数按照utf8的规则，将多个char组合起来，得到一个Unicode编码值，存储在一个wchar_t中。</p>
<h2 id="编码转换">编码转换</h2><p>一般的编码转换，直接映射相对较难，需要比较多的工作量，大多数情况下选择Unicode作为转换中介。</p>
<p>Linux上的iconv项目是一个比较成熟第三方库，其实质也是以Unicode作为转换的中介。具体可参阅<a href="http://www.gnu.org/software/libiconv/?cm_mc_uid=61509682042514188180227&amp;cm_mc_sid_50200000=1472309727" target="_blank" rel="external">iconv相关网站</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://shijianguang.github.io/2016/08/27/C-wchar-t-表示中文字符/" data-id="cisg8uybo0000dqs6ppbdjp84" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Charset/">Charset</a></li></ul>

    </footer>
  </div>
  
</article>



    
      <article id="post-Tips-of-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/15/Tips-of-Java/">Tips of Java</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2016/08/15/Tips-of-Java/">
      <time datetime="2016-08-15T07:38:50.000Z" itemprop="datePublished">2016-08-15</time>
    </a>
  </div>


          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Work/">Work</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <h2 id="1-_Collection_类型">1. Collection 类型</h2><p>在Java中，我们考虑一下 <strong>Set</strong> 和 <strong>Set&lt;?&gt;</strong> 这两种方式的区别，参见如下code:</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List <span class="built_in">list</span>, Object o)</span> </span>{
        <span class="built_in">list</span>.add(o);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        List&lt;String&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();
        add(<span class="built_in">list</span>, <span class="number">10</span>);
        System.out.println(<span class="built_in">list</span>.get(<span class="number">0</span>));
}
</code></pre><p>这段code在编译的时候不会出现问题，但运行的时候会在 <code>list.get(0)</code> 处抛出异常：</p>
<pre><code>Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="class">.lang</span><span class="class">.ClassCastException</span>: java<span class="class">.lang</span><span class="class">.Integer</span> cannot be cast to java<span class="class">.lang</span><span class="class">.String</span>
</code></pre><p>这里主要因为Java的泛型是通过编译时期保障的，如果使用原始类型，即像 <code>List</code> 这样的类型，就跳过了编译时的参数检查，所以这个类型的错误就被推迟到了运行时才体现出来。</p>
<p>接下来我们看一下 <strong>Set</strong> 和 <strong>Set&lt;?&gt;</strong> 的区别。<br>首先我们看一下 <strong>Set&lt;?&gt;</strong> 的两条准则：</p>
<ol>
<li>由于？是通配符，表示任意类型，所以Set&lt;?&gt;可以保存任何类型的数据</li>
<li>由于我们不知道？表示什么类型，所以我们不能像Set&lt;?&gt;中添加元素</li>
</ol>
<p>这两句话看似矛盾，我们通过两个例子分别说明第一点和第二点<br>针对第一点，从如下的代码中可以看到，使用<strong>List&lt;?&gt;</strong>做参数，我们可以将<strong>List<integer></integer></strong>和<strong>List<string></string></strong>传给print函数，同事print函数里面可以使用Object进行循环：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
    List&lt;Integer&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();
    printList(l1);

    List&lt;String&gt; l2 = <span class="keyword">new</span> ArrayList&lt;&gt;();
    printList(l2);
}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSet</span><span class="params">(List&lt;?&gt; <span class="built_in">list</span>)</span> </span>{
    <span class="keyword">for</span>(Object ele : <span class="built_in">list</span>) {
        System.out.println(ele)
    }
}
</code></pre><p>针对第二点，从如下的非法code片段中可以理解它，这里<strong>list.add(10)</strong>是非法的，因为他是<strong>List&lt;?&gt;</strong>类型，无法确定泛型的类型，所以无法添加元素到其中:</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSet</span><span class="params">(List&lt;?&gt; <span class="built_in">list</span>)</span> </span>{
    <span class="built_in">list</span>.add(<span class="number">10</span>);
    <span class="keyword">for</span>(Object ele : <span class="built_in">list</span>) {
        System.out.println(ele)
    }
}
</code></pre><p>如果上述code中，将类型从<strong>List&lt;?&gt;</strong>换乘<strong>List</strong>，那么就不会有问题。但存在类型不安全的隐患，因为<strong>List</strong>类型跳过了类型检查。</p>
<p>所以<strong>&lt;?&gt;</strong>只能被用在参数中，当你不关心传入的泛型具体是什么类型是，可以使用<strong>&lt;?&gt;</strong></p>
<h2 id="2-_静态常量初始化问题">2. 静态常量初始化问题</h2><p>最近在工作中遇到了一个关于静态初始化的问题，这个问题可以抽象成下面的代码片段来展示问题的根源：</p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] argvs</span>) </span>{
    System.<span class="keyword">out</span>.println(StaticFinalInit.TEXT);
    System.<span class="keyword">out</span>.println(StaticInit.TEXT);

    StaticArrayInit[] array = <span class="keyword">new</span> StaticArrayInit[<span class="number">10</span>];
    System.<span class="keyword">out</span>.println(array.length);
}

<span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticFinalInit</span> {
    <span class="keyword">public</span> <span class="keyword">static</span> final String TEXT = <span class="string">"Hello"</span>;

    <span class="keyword">static</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"Static Final Init"</span>);
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInit</span> {
    <span class="keyword">public</span> <span class="keyword">static</span> String TEXT = <span class="string">"Hello"</span>;

    <span class="keyword">static</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"Static Init"</span>);
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticArrayInit</span> {
    <span class="keyword">public</span> <span class="keyword">static</span> String TEXT = <span class="string">"Hello"</span>;

    <span class="keyword">static</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"Static Array Init"</span>);
    }
}

<span class="keyword">static</span> <span class="keyword">class</span> <span class="title">NonRefStatic</span> {
    <span class="keyword">public</span> <span class="keyword">static</span> String TEXT = <span class="string">"Hello"</span>;

    <span class="keyword">static</span> {
        System.<span class="keyword">out</span>.println(<span class="string">"Non Ref Static Init"</span>);
    }
}

Output:
Hello
Static Init
Hello
<span class="number">10</span>
</code></pre><p>从结果上可以发现如下问题：</p>
<ol>
<li>NonRefStatic这个类的静态初始化函数并没有被调用，这是因为我们的整个代码中并没有引用到这个类，所以这个类没有被加载，而静态初始化函数是在类加载过程中被调用，所以NonRefStatic的静态构造函数并没有被调用</li>
<li>StaticFinalInit这个类的静态初始化函数也没有被调用，这是因为TEXT是一个常量字段，编译的时候这个常量会进入常量池，调用的时候直接访问常量池，并没有引用定义常量的类，所以定义常量的类相当于没有被加载，所以静态构造函数没有被调用</li>
<li>Java实例化数组是，并没有实例化数组中的每一个元素，不会触发这个类的各种初始化过程</li>
</ol>
<p>在工作中遇到的问题与第二点比较相像。工程中定义了一个ConfigUtil类，里面定义了一些系统参数，并同时在resource中加入config.properties文件，ConfigUtil类在静态初始化是去加载这个resource文件，在config.properties文件中将配置项的名字命名成与ConfigUtil类中的名字一样，这样通过反射自动将ConfigUtil中的系统参数变量的值替换为文件中的值，并且新增配置项只要遵守这个规则，在两个地方定义名字相同，就可自动加载。但期初这个方法并不生效，配置文件中的取值时候加载不到ConfigUtil类中，最后经排查，问题与第二点类似，因为在ConfigUtil中将变量生命成了final，并且给了默认值，所以当程序读取ConfigUtil中的变量时，直接读取常量池，根本没有出发静态初始化</p>
<p>Java中的各种初始化调用顺序：静态变量定义时的初始化值-&gt;静态初始化快-&gt;普通变量定义时的初始化值-&gt;初始化块-&gt;构造函数</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://shijianguang.github.io/2016/08/15/Tips-of-Java/" data-id="cisg8uycl0008dqs6ycyoon6l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>



    
      <article id="post-CSAPP-Optimizing-Program-Performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/16/CSAPP-Optimizing-Program-Performance/">Optimizing Program Performance</a>
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2015/08/16/CSAPP-Optimizing-Program-Performance/">
      <time datetime="2015-08-16T05:54:40.000Z" itemprop="datePublished">2015-08-16</time>
    </a>
  </div>


          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Reading-Note/">Reading Note</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <h2 id="Preface">Preface</h2><p>The primary objective in writing a program is must be to make it work correctly under all possible conditions. A program that runs fast but gives incorrect results is useless. But on the other hand, making a program fast is also important. For a program which need to run one or two days, 20% faster than before is a significant improvement.</p>
<p>To write an efficient program require several types of activities:</p>
<ol>
<li>Select appropriate data structures and algorithms.</li>
<li>We must write source code that compiler can effectively optimize to turn into efficient executable code.</li>
<li>For modern multi-core CPU, divide a task into portions that can be computed in parallel</li>
</ol>
<p>For part 1, it depends on the problem you are facing to. Take sort for example, every on know heap sort is O(nlgn) and an insert sort is O(n^2), but if the size of the array which need to be sort is small, say 4 or 8, inert sort may be faster than heap sort because the constant of O()</p>
<p>For part 3, the most important thing is how to divide the task and how to decrease confliction. If you can divide the origin task into four part and they don’t depend on each other during computing, you will get 4x speed on a 4 cores CPU.</p>
<p>This blog will focus on part 2. First we will discuss how to measure the speed or efficiency of a programm. Secondly, we will discuss the limitation of compiler. Then we will discuss two point of optimizing your program: eliminate unnecessary part of your program and leverage instrument parallel. At last, we will show some useful tools.</p>
<h2 id="Metrics_for_Program_Speed">Metrics for Program Speed</h2><p>Here, we introduce a metric named <strong>Cycles Per Element</strong>, abbreviate <strong>CPE</strong>. It means that how many CPU clock cycles one element need. It can help us understand loop performance of iterative program in a detailed level.</p>
<h2 id="Limitation_of_Compiler">Limitation of Compiler</h2><p>As you know, modern compilers employ sophisticated algorithms to do optimization for our program. For example, GCC provide -O1, -O2 and -O3 levels for user to select. One shortcoming of high level optimization is that it will make the program harder to debug for programmer and standard debugging tool.</p>
<p>Although compilers can do optimization for us, it has a rule that compilers must do <strong>safe optimizations</strong> to a program, meaning that the resulting program will have the exact same behavior as would an unoptimized version for all possible cases the program may encounter. Up to this safe optimization, we need to do more things to make compiler produce more efficient machine-level code. Let us see an example.</p>
<p>Look at the following code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *xp, <span class="keyword">volatile</span> <span class="keyword">int</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle2</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *xp, <span class="keyword">volatile</span> <span class="keyword">int</span> *yp)</span> </span>&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * (*yp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>At first glance, both the two function do the same thing. But in my computer, function <em>twiddle1</em> takes 5777us for 1,000,000 times call and function <em>twiddle2</em> takes 3656us. Function <em>twiddle2</em> is almost <strong>40% faster</strong> than function <em>twiddle1</em>. The reason is that function <em>twiddle1</em> need six memory references and function <em>twiddle2</em> only need three. You may think why compiler not try to optimize function <em>twiddle1</em> to have three memory references as function <em>twiddle2</em> does. The reason is safe optimization rule. Consider if the address of xp and yp is equals, the two function will give different result. So even you know the function actually can’t encounter the xp == yp situation, the compiler will not do the optimization. What you can do is use function <em>twiddle2</em> code instead of function <em>twiddle1</em>.</p>
<h2 id="Code_Example_and_environment">Code Example and environment</h2><p>My computer environment:<br>  CPU: 2.5GHz<br>  GCC Optimization Level: O1</p>
<p>Pre-define Code:<br>Here the code snippet pre-defines some structures and functions which will be use in the following parts.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">data_t</span> *data;</span><br><span class="line">&#125; vec_rec, *vec_ptr;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IDENT <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> OP +</span></span><br><span class="line"></span><br><span class="line"><span class="function">vec_ptr <span class="title">new_vec</span><span class="params">(<span class="keyword">long</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    vec_ptr result = (vec_ptr) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(vec_rec));</span><br><span class="line">    <span class="keyword">if</span>(!result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    result-&gt;len = len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">data_t</span> * data = (<span class="keyword">data_t</span> *)<span class="built_in">calloc</span>(len, <span class="keyword">sizeof</span>(<span class="keyword">data_t</span>));</span><br><span class="line">        <span class="keyword">if</span>(!data) &#123;</span><br><span class="line">            <span class="built_in">free</span>((<span class="keyword">void</span> *) result);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result-&gt;data = data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_vec_element</span><span class="params">(vec_ptr v, <span class="keyword">long</span> <span class="keyword">int</span> index, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= v-&gt;len)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    *dest = v-&gt;data[index];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">vec_length</span><span class="params">(vec_ptr v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here is a first version of combine function, called <strong>combine1</strong>, we will optimize it step by step.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine1</span><span class="params">(vec_ptr v, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; vec_length(v) ; ++ i) &#123;</span><br><span class="line">        <span class="keyword">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Eliminate_Unnecessary_Part">Eliminate Unnecessary Part</h2><h3 id="Tip_1:_Eliminate_inefficient_code_piece_in_loop">Tip 1: Eliminate inefficient code piece in loop</h3><p>From the <strong>combine1</strong> function, we can see that <strong>vec_length</strong> is the test condition of the FOR LOOP. This function will be invoked for each iteration of the loop. But actually, we will not change the length of the vector in the loop. We can get the length before the loop start and use it during the loop. Here is the second version of combine function, called <strong>combine2</strong>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine2</span><span class="params">(vec_ptr v, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> length = vec_length(v);</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; ++ i) &#123;</span><br><span class="line">        <span class="keyword">data_t</span> val;</span><br><span class="line">        get_vec_element(v, i, &amp;val);</span><br><span class="line">        *dest = *dest OP val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In <strong>combine2</strong>, we first get the length and then begin the loop. For a 10,000,000 vector, <strong>combine1</strong> use 33734us and <strong>combine2</strong> use 21763us on my computer using O1 optimization for GCC. The <strong>CPE</strong> for <strong>combine1</strong> is 8.43 and <strong>combine2</strong> is 5.44.</p>
<h3 id="Tip_2:_Reduce_function_invokation">Tip 2: Reduce function invokation</h3><p>In <strong>combine2</strong> function, <strong>get_vec_element</strong> will be called once per iteration. In <strong>get_vec_element</strong> function, it will check the <strong>index</strong> param whether it is out of bound or not. Both the function call and the inner check is redundant. We can get the start address of the vector before the loop and access the vector data directly. Here is the third version of combine function, called <strong>combine3</strong>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> *get_vec_start(vec_ptr v) &#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine3</span><span class="params">(vec_ptr v, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> length = vec_length(v);</span><br><span class="line">    <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; ++ i) &#123;</span><br><span class="line">        *dest = *dest OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>When gcc use O1 level optimization on my computer, the lift is not obvious. When gcc use O0 level optimization, <strong>combine3</strong> has 50% performance lift comparing with <strong>combine2</strong>.</p>
<h3 id="Tip_3:_Eliminate_unnecessary_memory_reference">Tip 3: Eliminate unnecessary memory reference</h3><p>For each iteration in <strong>combine3</strong> function, it will load <strong>dest</strong>, do the operation and store the new value to <strong>dest</strong>. But we don’t need access <strong>dest</strong> memory every time actually. What we need is just store the result to <strong>dest</strong> before we return from the function. Here is the forth version of combine function, called <strong>combine4</strong>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> length = vec_length(v);</span><br><span class="line">    <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="keyword">data_t</span> acc = IDENT;</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; length ; ++ i) &#123;</span><br><span class="line">        acc = acc OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>For a 10,000,000 vector on my computer, <strong>combine4</strong> use 4241us and the CPE is 1.06. The reason why performance lift so much is that we eliminate two unnecessary memory reference: read from <strong>dest</strong> and store to <strong>dest</strong>.<br>Here is the two inner loop ASM code:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LBB6_1:                                 ## %.lr.ph&#10;                                        ## =&#62;This Inner Loop Header: Depth=1&#10;&#9;movl&#9;(%rax), %ecx&#10;&#9;addl&#9;%ecx, (%r14)&#10;&#9;addq&#9;$4, %rax&#10;&#9;decq&#9;%rbx&#10;&#9;jne&#9;LBB6_1</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LBB7_1:                                 ## %.lr.ph&#10;                                        ## =&#62;This Inner Loop Header: Depth=1&#10;&#9;addl&#9;(%rax), %ecx&#10;&#9;addq&#9;$4, %rax&#10;&#9;decq&#9;%rbx&#10;&#9;jne&#9;LBB7_1</span><br></pre></td></tr></table></figure>
<p>The first one is <strong>combine3</strong>‘s ASM code and the second is <strong>combine4</strong>‘s. You can see there is a movl instruction in the beginning of each iteration and addl instruction store the result to a memory address. These are the two unnecessary memory reference.</p>
<h1 id="Leverage_Instrument_Parallel">Leverage Instrument Parallel</h1><p>Modern CPU architecture has pipeline and superscalar which means it can emit more than one instruction in a CPU cycle. In <strong>combine4</strong>, however, next add instruction must wait the current instruction finish because they all depend on <strong>acc</strong> variable. The first add instruction must write the value to <strong>acc</strong>, then the second instruction can begin. So if we expend the loop and use multi variable to accumulate the result, we will leverage CPU’s pipeline and superscalar features. Here is the fifth version of combine called <strong>combine5</strong>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine5</span><span class="params">(vec_ptr v, data_t *dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> length = vec_length(v);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> limit = length - <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">data_t</span> *data = get_vec_start(v);</span><br><span class="line">    <span class="keyword">data_t</span> acc0 = IDENT;</span><br><span class="line">    <span class="keyword">data_t</span> acc1 = IDENT;</span><br><span class="line">    <span class="keyword">data_t</span> acc2 = IDENT;</span><br><span class="line">    <span class="keyword">data_t</span> acc3 = IDENT;</span><br><span class="line"></span><br><span class="line">    *dest = IDENT;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; limit ; i += <span class="number">4</span>) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">        acc1 = acc1 OP data[i + <span class="number">1</span>];</span><br><span class="line">        acc2 = acc2 OP data[i + <span class="number">2</span>];</span><br><span class="line">        acc3 = acc3 OP data[i + <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; i &lt; length ; ++ i) &#123;</span><br><span class="line">        acc0 = acc0 OP data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dest = acc0 OP acc1 OP acc2 OP acc3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In <strong>combine5</strong>, we use four variables to do the accumulation. Besides the advantage of pipeline and superscalar, it also reduce the loop condition judgement time and loop index increase operation time. They both are not the major part of the combine function. For a 10,000,000 vector on my computer, <strong>combine5</strong> use 2898us and the CPE is 0.72.</p>
<p>Above it all test on <strong>int</strong> type addition, Here we also give a conclusion table for <strong>float</strong> type addition. You can see even using O2 level optimization, <strong>combine5</strong>‘s CPE is <strong>combine1</strong>‘s half.<br>Function | -O1 us | -O1 CPE | -O2 us | -O2 CPE<br>:—————|:—————|:—————|:—————|:—————<br>combine1 | 34013 | 8.5 | 9136 | 2.28<br>combine5 | 6023 | 1.5 | 4508 | 1.12</p>
<h2 id="Useful_tool">Useful tool</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://shijianguang.github.io/2015/08/16/CSAPP-Optimizing-Program-Performance/" data-id="cisg8uycn000cdqs6iehpq1ee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/System-Programming/">System Programming</a></li></ul>

    </footer>
  </div>
  
</article>



    </section>
      
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">recents</h3>
    <div class="widget">
      <ul id="recent-post" class="">
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2016/08/28/C-右值引用和转移语义/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"></p>
              <p class="item-title"><a href="/2016/08/28/C-右值引用和转移语义/" class="title">C++ 右值引用和转移语义</a></p>
              <p class="item-date"><time datetime="2016-08-28T04:13:02.000Z" itemprop="datePublished">2016-08-28</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2016/08/27/C-wchar-t-表示中文字符/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Work/">Work</a></p>
              <p class="item-title"><a href="/2016/08/27/C-wchar-t-表示中文字符/" class="title">C++ wchar_t 表示中文字符</a></p>
              <p class="item-date"><time datetime="2016-08-27T12:32:36.000Z" itemprop="datePublished">2016-08-27</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2016/08/15/Tips-of-Java/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Work/">Work</a></p>
              <p class="item-title"><a href="/2016/08/15/Tips-of-Java/" class="title">Tips of Java</a></p>
              <p class="item-date"><time datetime="2016-08-15T07:38:50.000Z" itemprop="datePublished">2016-08-15</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-thumbnail">
              <a href="/2015/08/16/CSAPP-Optimizing-Program-Performance/" class="thumbnail">
  
    <span class="thumbnail-image thumbnail-none"></span>
  
</a>
            </div>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Reading-Note/">Reading Note</a></p>
              <p class="item-title"><a href="/2015/08/16/CSAPP-Optimizing-Program-Performance/" class="title">Optimizing Program Performance</a></p>
              <p class="item-date"><time datetime="2015-08-16T05:54:40.000Z" itemprop="datePublished">2015-08-16</time></p>
            </div>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Reading-Note/">Reading Note</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Work/">Work</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/">C/C++</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Charset/">Charset</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/System-Programming/">System Programming</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">tag cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-C/" style="font-size: 20px;">C/C++</a> <a href="/tags/Charset/" style="font-size: 10px;">Charset</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/System-Programming/" style="font-size: 10px;">System Programming</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 - 2016 Jianguang Shi<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>